{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to My Blog","text":""},{"location":"#recent-posts","title":"Recent Posts","text":""},{"location":"#django-database-connection-pooling-with-pgbouncermarch-05-2023-python-django-postgresql-docker-pgbouncer-tutorial","title":"Django Database Connection Pooling with PgBouncerMarch 05, 2023 |  python  |  django  |  postgresql  |  docker  |  pgbouncer  |  tutorial","text":"<p>An example of Django PostgreSQL Database Connection Pooling with PgBouncer</p>"},{"location":"#build-a-python-cli-tool-with-rustfebruary-25-2023-rust-python-cli-tutorial","title":"Build a Python CLI Tool with RustFebruary 25, 2023 |  rust  |  python  |  cli  |  tutorial","text":"<p>A simple example of how to build a Python CLI tool with Rust</p>"},{"location":"tags/","title":"Tags","text":"<p>Following is a list of relevant tags:</p>"},{"location":"tags/#cli","title":"cli","text":"<ul> <li>Build a Python CLI Tool with Rust</li> </ul>"},{"location":"tags/#django","title":"django","text":"<ul> <li>Django Database Connection Pooling with PgBouncer</li> </ul>"},{"location":"tags/#docker","title":"docker","text":"<ul> <li>Django Database Connection Pooling with PgBouncer</li> </ul>"},{"location":"tags/#pgbouncer","title":"pgbouncer","text":"<ul> <li>Django Database Connection Pooling with PgBouncer</li> </ul>"},{"location":"tags/#postgresql","title":"postgresql","text":"<ul> <li>Django Database Connection Pooling with PgBouncer</li> </ul>"},{"location":"tags/#python","title":"python","text":"<ul> <li>Build a Python CLI Tool with Rust</li> <li>Django Database Connection Pooling with PgBouncer</li> </ul>"},{"location":"tags/#rust","title":"rust","text":"<ul> <li>Build a Python CLI Tool with Rust</li> </ul>"},{"location":"tags/#tutorial","title":"tutorial","text":"<ul> <li>Build a Python CLI Tool with Rust</li> <li>Django Database Connection Pooling with PgBouncer</li> </ul>"},{"location":"posts/","title":"All Posts","text":""},{"location":"posts/#django-database-connection-pooling-with-pgbouncermarch-05-2023-python-django-postgresql-docker-pgbouncer-tutorial","title":"Django Database Connection Pooling with PgBouncerMarch 05, 2023 |  python  |  django  |  postgresql  |  docker  |  pgbouncer  |  tutorial","text":"<p>An example of Django PostgreSQL Database Connection Pooling with PgBouncer</p>"},{"location":"posts/#build-a-python-cli-tool-with-rustfebruary-25-2023-rust-python-cli-tutorial","title":"Build a Python CLI Tool with RustFebruary 25, 2023 |  rust  |  python  |  cli  |  tutorial","text":"<p>A simple example of how to build a Python CLI tool with Rust</p>"},{"location":"posts/build-python-cli-tool-with-rust/","title":"Build a Python CLI Tool with Rust February 25, 2023","text":"","tags":["rust","python","cli","tutorial"]},{"location":"posts/build-python-cli-tool-with-rust/#introduction","title":"Introduction","text":"<p>In this tutorial, we will build a simple Python CLI tool with Rust. The tool will search for a given string in the given directory and print the file names that contain the string.</p>","tags":["rust","python","cli","tutorial"]},{"location":"posts/build-python-cli-tool-with-rust/#prerequisites","title":"Prerequisites","text":"<p>To follow this tutorial, you need to have the following installed:</p> <ul> <li>Rust</li> <li>Cargo</li> <li>Python 3.7 or later</li> </ul>","tags":["rust","python","cli","tutorial"]},{"location":"posts/build-python-cli-tool-with-rust/#create-a-new-rust-project","title":"Create a New Rust project","text":"<p>First, we need to create a new Rust project that will contain the code for our CLI tool. We will use the <code>cargo</code> to create the project and we will call it <code>findrs</code>:</p> <pre><code>cargo new --bin findrs\n</code></pre> <p>The directory structure of the project will look like this:</p> <pre><code>findrs/\n\u251c\u2500\u2500 Cargo.toml\n\u2514\u2500\u2500 src\n    \u2514\u2500\u2500 main.rs\n</code></pre>","tags":["rust","python","cli","tutorial"]},{"location":"posts/build-python-cli-tool-with-rust/#parse-command-line-arguments","title":"Parse Command-Line Arguments","text":"","tags":["rust","python","cli","tutorial"]},{"location":"posts/build-python-cli-tool-with-rust/#add-the-clap-crate-to-the-project","title":"Add the <code>clap</code> Crate to the Project","text":"<p>The <code>clap</code> crate is a command-line argument parser for Rust. We can use this crate to parse the command-line arguments for <code>findrs</code>. To add the <code>clap</code> to our project, we can run the following command:</p> <pre><code>cargo add clap --features derive # (1)!\n</code></pre> <ol> <li>This will add the latest version of <code>clap</code> crate to the <code>Cargo.toml</code> file under the <code>[dependencies]</code> section.     <pre><code>[dependencies]\nclap = { version = \"4.1.1\", features = [\"derive\"] }\n</code></pre></li> </ol>","tags":["rust","python","cli","tutorial"]},{"location":"posts/build-python-cli-tool-with-rust/#add-clap-argument-parser-to-the-project","title":"Add <code>clap</code> Argument Parser to the Project","text":"<p>Now, we can add the <code>clap</code> argument parser our the project. Let's add the following code to the <code>main.rs</code> file:</p> <pre><code>use std::path::PathBuf;\nuse clap::Parser;  // (1)!\n#[derive(Debug, Parser)]  // (2)!\n#[command(about = \"Find all files containing a given name.\")]  // (3)!\npub struct Arguments {\n/// Name to find.  // (4)!\n#[arg(short, long)]  // (5)!\npub name: String, // (6)!\n/// Path to to check.\n#[arg(default_value = \".\")] // (7)!\npub path: PathBuf, // (8)!\n}\nfn main() {\nlet args = Arguments::parse();  // (9)!\nprintln!(\"{:?}\", args);\n}\n</code></pre> <ol> <li>Import <code>calp</code>'s <code>Parser</code> trait.</li> <li>Derive the <code>Debug</code> and <code>Parser</code> traits for the <code>Arguments</code> struct.</li> <li>Add the <code>about</code> attributes to the <code>Arguments</code> struct. This will show-up in the help message.</li> <li>Add help message to the <code>name</code> field.</li> <li>Add the <code>arg</code> attributes to the <code>name</code> field. This will add the <code>--name</code> and <code>-n</code> flags to the <code>findrs</code> CLI tool.</li> <li>Add the <code>name</code> field to the <code>Arguments</code> struct. This field will be used to store the name that we want to match with the file names.</li> <li>Add the <code>default_value</code> attribute to the <code>path</code> field. This will set the default value of the <code>path</code> field to <code>.</code> (current directory).</li> <li>Add the <code>path</code> field to the <code>Arguments</code> struct. This field will be used to store the path to the directory that we want to search for the given name.</li> <li>Parse the command-line arguments and store them in the <code>args</code> variable.</li> </ol> <p>Now, we can run the <code>findrs</code> CLI tool with the <code>--help</code> flag to see the help message:</p> <pre><code>cargo run -- --help\n</code></pre> <p>Output: <pre><code>Find all files containing a given name.\n\nUsage: findrs --name &lt;NAME&gt; [PATH]\nArguments:\n  [PATH]  Path to to check [default: .]\nOptions:\n  -n, --name &lt;NAME&gt;  Name to find\n  -h, --help         Print help\n</code></pre></p> <p>You can run the <code>findrs</code> CLI tool with cargo by running the following command:</p> <pre><code>cargo run -- --name test ~/Desktop\n</code></pre> <p>Output: <pre><code>Arguments { name: \"test\", path: \"/home/saad/Desktop\" }\n</code></pre></p> <p>Here you can see that the <code>name</code> and <code>path</code> fields of the <code>Arguments</code> struct are set to the values that we passed to the <code>findrs</code> CLI tool.</p>","tags":["rust","python","cli","tutorial"]},{"location":"posts/build-python-cli-tool-with-rust/#search-for-the-files-that-contain-the-given-name","title":"Search for the Files that Contain the Given Name","text":"","tags":["rust","python","cli","tutorial"]},{"location":"posts/build-python-cli-tool-with-rust/#add-the-walkdir-crate-to-the-project","title":"Add the <code>walkdir</code> Crate to the Project","text":"<p>The <code>walkdir</code> crate is a Rust library for walking a directory tree. We can use this crate to search for the files that contain the given name. To add the <code>walkdir</code> to our project, we can run the following command:</p> <pre><code>cargo add workdir # (1)!\n</code></pre> <ol> <li>This will add the latest version of <code>workdir</code> crate to the <code>Cargo.toml</code> file under the <code>[dependencies]</code> section.     <pre><code>[dependencies]\nclap = { version = \"4.1.6\", features = [\"derive\"] }\nwalkdir = \"2.3.2\"\n</code></pre></li> </ol>","tags":["rust","python","cli","tutorial"]},{"location":"posts/build-python-cli-tool-with-rust/#update-the-mainrs-file","title":"Update the <code>main.rs</code> File","text":"<p>Now, we can update the <code>main.rs</code> file to search for the files that contain the given name. Let's add the following code to the <code>main.rs</code> file:</p> <pre><code>use std::ffi::OsStr;  // (1)!\nuse std::path::PathBuf;\nuse clap::Parser;\nuse walkdir::WalkDir;  // (2)!\n#[derive(Debug, Parser)]\n#[command(author, about = \"Find all files containing a given name.\")]\npub struct Arguments {\n/// Name to find.\n#[arg(short, long)]\npub name: String,\n/// Path to to check.\n#[arg(default_value = \".\")]\npub path: PathBuf,\n}\nfn main() {\nlet args = Arguments::parse();\nfor entry in WalkDir::new(&amp;args.path).into_iter().filter_map(|e| e.ok()) {  // (3)!\nlet path = entry.path();\nif path.is_file() {  // (4)!\nmatch &amp;path.file_name().and_then(OsStr::to_str) {  // (5)!\nSome(name) if name.contains(&amp;args.name) =&gt; println!(\"{}\", path.display()),  // (6)!\n_ =&gt; (),  // (7)!\n}\n}\n}\n}\n</code></pre> <ol> <li>Import <code>OsStr</code> struct.</li> <li>Import <code>walkdir</code>'s <code>WalkDir</code> struct.</li> <li>Iterate over all entries in the given directory and ignore any errors that may arise.</li> <li>Check if the entry is a file.</li> <li>Get the file name of the entry and convert it to a <code>&amp;str</code>.</li> <li>If the file name contains the given name, print the path to the file.</li> <li>If the file name doesn't contain the given name or is <code>None</code> variant, do nothing.</li> </ol> <p>Now, we can run the <code>findrs</code> CLI tool with the <code>--name</code> flag and the directory to search for the files that contain the given name:</p> <pre><code>cargo run -- --name test ~/Desktop\n</code></pre> <p>Output: <pre><code>/home/saad/Desktop/test.txt\n/home/saad/Desktop/testing.py\n</code></pre></p>","tags":["rust","python","cli","tutorial"]},{"location":"posts/build-python-cli-tool-with-rust/#prepare-the-project-to-run-with-python","title":"Prepare the Project to Run with Python","text":"","tags":["rust","python","cli","tutorial"]},{"location":"posts/build-python-cli-tool-with-rust/#install-maturin","title":"Install <code>maturin</code>","text":"<p>Install <code>maturin</code> inside a <code>virtualenv</code> by running the following command:</p> <pre><code>python -m venv .venv\nsource .venv/bin/activate\npip install -U pip maturin\n</code></pre>","tags":["rust","python","cli","tutorial"]},{"location":"posts/build-python-cli-tool-with-rust/#add-pyprojecttoml-file","title":"Add <code>pyproject.toml</code> File","text":"<p>Now, we can add the <code>pyproject.toml</code> file at the root of the project. </p> <pre><code>findrs/\n\u251c\u2500\u2500 Cargo.toml\n\u251c\u2500\u2500 pyproject.toml\n\u2514\u2500\u2500 src\n    \u2514\u2500\u2500 main.rs\n</code></pre> <p>Let's add the following code to the <code>pyproject.toml</code> file:</p> <pre><code>[build-system]\nrequires = [\"maturin&gt;=0.14,&lt;0.15\"] # (1)!\nbuild-backend = \"maturin\" # (2)!\n[project]\nname = \"findrs\" # (3)!\ndescription = \"Find all files containing a given name.\" # (4)!\nrequires-python = \"&gt;=3.7\" # (5)!\n[tool.maturin]\nbindings = \"bin\" # (6)!\nstrip = true # (7)!\n</code></pre> <ol> <li>This specifies the version of <code>maturin</code> that we want to use.</li> <li>We need to use <code>maturin</code> as the build backend for the project.</li> <li>Specify the name of the package as <code>findrs</code>.</li> <li>Add the description of the package.</li> <li>Specify the minimum version of Python that we want to support.</li> <li>In our case, we want to generate bindings for a binary because it is a CLI tool.</li> <li>Strip the library for minimum file size.</li> </ol>","tags":["rust","python","cli","tutorial"]},{"location":"posts/build-python-cli-tool-with-rust/#build-and-install-the-module-with-maturin","title":"Build and install the module with <code>maturin</code>","text":"","tags":["rust","python","cli","tutorial"]},{"location":"posts/build-python-cli-tool-with-rust/#for-development","title":"For Development","text":"<p>For local development, the maturin can be used to build the package and install it to virtualenv.</p> <pre><code>maturin develop\n</code></pre> <p>We can also run pip install directly from project root directory:</p> <pre><code>pip install -e .\n</code></pre> <p>Now we can run the <code>findrs</code> CLI tool directly from the terminal:</p> <pre><code>findrs --name test ~/Desktop\n</code></pre>","tags":["rust","python","cli","tutorial"]},{"location":"posts/build-python-cli-tool-with-rust/#create-a-wheel-for-distribution","title":"Create a wheel for distribution","text":"<p>Now, we can create wheels for distribution:</p> <pre><code>maturin build\n</code></pre> <p>This will create a <code>wheel</code> file in the <code>target/wheels</code> directory.</p> <p>We can install the wheel file using <code>pip</code>:</p> <pre><code>pip install target/wheels/&lt;file-name&gt;.whl\n</code></pre>","tags":["rust","python","cli","tutorial"]},{"location":"posts/build-python-cli-tool-with-rust/#publish-the-package-to-pypi","title":"Publish the Package to PyPI","text":"<p>Now, we can publish the package to PyPI. First, we need to create an account on PyPI. Then run the following command to upload the package to PyPI:</p> <pre><code>maturin publish\n</code></pre>","tags":["rust","python","cli","tutorial"]},{"location":"posts/build-python-cli-tool-with-rust/#integrate-github-actions","title":"Integrate GitHub Actions","text":"<p>We can use GitHub actions to run the tests and publish the package to PyPI automatically. To generate the GitHub actions workflow file, we can run the following command:</p> <pre><code>maturin generate-ci github\n</code></pre>","tags":["rust","python","cli","tutorial"]},{"location":"posts/build-python-cli-tool-with-rust/#useful-references","title":"Useful References","text":"<p>Install Rust: https://www.rust-lang.org/tools/install</p> <p>Rust Book: https://doc.rust-lang.org/book/</p> <p>Maturin Documentation: https://www.maturin.rs/index.html</p>","tags":["rust","python","cli","tutorial"]},{"location":"posts/build-python-cli-tool-with-rust/#conclusion","title":"Conclusion","text":"<p><code>maturin</code> has made it very easy to build and publish Python packages built with Rust. This tutorial showcases a simple example of that. I hope you found this useful.</p>","tags":["rust","python","cli","tutorial"]},{"location":"posts/django-postgresql-database-connection-pooling-with-pgbouncer/","title":"Django PostgreSQL Database Connection Pooling with PgBouncer March 5, 2023","text":"","tags":["python","django","postgresql","docker","pgbouncer","tutorial"]},{"location":"posts/django-postgresql-database-connection-pooling-with-pgbouncer/#introduction","title":"Introduction","text":"<p>In this post, we will learn how to use PostgreSQL database connection pooling with PgBouncer for Django applications.</p>","tags":["python","django","postgresql","docker","pgbouncer","tutorial"]},{"location":"posts/django-postgresql-database-connection-pooling-with-pgbouncer/#what-is-database-connection-pooling","title":"What is database connection pooling?","text":"<p>Database connection pooling is a technique that allows an application to reuse database connections instead of creating a new connection for each request. This reduces the cost of opening and closing connections to the database server by maintaining a pool of connections that can be reused. This improves the performance of the database and reduces the number of connections to the database server.</p>","tags":["python","django","postgresql","docker","pgbouncer","tutorial"]},{"location":"posts/django-postgresql-database-connection-pooling-with-pgbouncer/#what-is-pgbouncer","title":"What is PgBouncer?","text":"<p>PgBouncer is a lightweight connection pooler for PostgreSQL. It can sit between the application and the database server and manage the connections to the database server.</p>","tags":["python","django","postgresql","docker","pgbouncer","tutorial"]},{"location":"posts/django-postgresql-database-connection-pooling-with-pgbouncer/#why-use-pgbouncer","title":"Why use PgBouncer?","text":"<ul> <li>Low memory requirements (2 kB per connection by default).</li> <li>This is because PgBouncer does not need to see full packets at once.</li> <li>It is not tied to one backend server.</li> <li>The destination databases can reside on different hosts.</li> </ul> <p>Note: This is copied from the PgBouncer Features Page.</p>","tags":["python","django","postgresql","docker","pgbouncer","tutorial"]},{"location":"posts/django-postgresql-database-connection-pooling-with-pgbouncer/#prerequisites","title":"Prerequisites","text":"<p>To follow this tutorial, you need to have the following installed:</p> <ul> <li>Docker</li> <li>Docker Compose</li> </ul> <p>We are going to use Docker and Docker Compose to run Django, PostgreSQL and PgBouncer.</p>","tags":["python","django","postgresql","docker","pgbouncer","tutorial"]},{"location":"posts/django-postgresql-database-connection-pooling-with-pgbouncer/#create-a-new-django-project","title":"Create a New Django Project","text":"<p>First, we need to create a project directory. We will call it <code>try-dj-pgbouncer</code>.</p> <pre><code>mkdir try-dj-pgbouncer\ncd try-dj-pgbouncer\n</code></pre> <p>Then, we need to create a <code>requirements.txt</code> file inside the project directory that will contain the dependencies for our Django project.</p> <pre><code>touch requirements.txt\n</code></pre> <p>Add the following dependencies to the <code>requirements.txt</code> file:</p> requirements.txt<pre><code>Django==4.1  # (1)!\npsycopg2==2.9.5  # (2)!\ndj-database-url==1.2.0 # (3)!\n</code></pre> <ol> <li>Specify the version of <code>Django</code> that we want to use.</li> <li>Specify the version of <code>psycopg2</code> that we want to use. This is the PostgreSQL database adapter for Python.</li> <li>Specify the version of <code>dj-database-url</code> that we want to use. This is a Django utility that allows us to configure the database using a URL.</li> </ol> <p>Now we can add the <code>Dockerfile</code> for our Django project.</p> <pre><code>touch Dockerfile\n</code></pre> <p>Add the following content to the <code>Dockerfile</code>:</p> Dockerfile<pre><code>FROM python:3.10-slim-bullseye\nENV PYTHONDONTWRITEBYTECODE=1\nENV PYTHONUNBUFFERED=1\n# Set the working directory\nWORKDIR /app\nRUN apt-get update \\\n&amp;&amp; apt-get install \\\n-y \\\n--no-install-recommends \\\n--no-install-suggests \\\n# Required for psycopg2\n       gcc \\\ng++ \\\nlibpq-dev \\\n&amp;&amp; apt-get clean \\\n&amp;&amp; rm -rf /var/lib/apt/lists/* /tmp/* /var/tmp/*\n\n# Copy requirements.txt to the container\nCOPY ./requirements.txt .\n\n# Install Python dependencies\nRUN pip install -r requirements.txt\n\n# Copy application code to the container\nCOPY . .\n</code></pre> <p>Let's build the Docker image.</p> <pre><code>docker build -t try-dj-pgbouncer .\n</code></pre> <p>Now, we can create a Django project using Docker.</p> <pre><code>docker run --rm -v $(pwd):/app try-dj-pgbouncer django-admin startproject try_dj_pgbouncer .\n</code></pre> <p>This command will create a Django project inside the current directory.</p> <p>We can also create a Django app called <code>core</code> using Docker.</p> <pre><code>docker run --rm -v $(pwd):/app try-dj-pgbouncer python manage.py startapp core\n</code></pre> <p>This command will create a Django app called <code>core</code> inside the <code>try-dj-pgbouncer</code> directory. We need to add the <code>core</code> app to the <code>INSTALLED_APPS</code> list in the <code>try_dj_pgbouncer/settings.py</code> file.</p> try_dj_pgbouncer/settings.py<pre><code>INSTALLED_APPS = [\n# ...\n'core',\n]\n</code></pre>","tags":["python","django","postgresql","docker","pgbouncer","tutorial"]},{"location":"posts/django-postgresql-database-connection-pooling-with-pgbouncer/#setup-docker-compose-for-django-and-postgresql","title":"Setup Docker Compose for Django and PostgreSQL","text":"<p>We need to create a <code>docker-compose.yaml</code> file at the root of the project (<code>try-dj-pgbouncer/</code>) that will contain the <code>docker-compose</code> configuration for our Django, PostgreSQL and PgBouncer services.</p> <pre><code>touch docker-compose.yaml\n</code></pre> <p>Add the following content to the <code>docker-compose.yaml</code> file:</p> docker-compose.yaml<pre><code>version: '3.9'\nservices:\nweb:  # (1)!\nbuild:\ncontext: .  # (2)!\nvolumes:\n- .:/app  # (3)!\nenv_file:\n- ./.env  # (4)!\nports:\n- 8000:8000  # (5)!\ndepends_on:\n- db  # (6)!\ncommand: &gt;  # (7)!\nbash -c \"while !&lt;/dev/tcp/db/5432; do sleep 1; done;\npython manage.py runserver 0.0.0.0:8000\"\ndb:\nimage: postgres:13.10-alpine  # (8)!\nenvironment:\n- POSTGRES_PASSWORD=postgres  # (9)!\nvolumes:\n- postgres_data:/var/lib/postgresql/data/  # (10)!\nhealthcheck:  # (11)!\ntest: [\"CMD-SHELL\", \"pg_isready -U postgres\"]\ninterval: 10s\ntimeout: 5s\nretries: 5\nvolumes:\npostgres_data:  # (12)!\n</code></pre> <ol> <li>The <code>web</code> service is the Django Application.</li> <li>The <code>build</code> context is the current directory where the <code>Dockerfile</code> is located.</li> <li>This will mount the current directory to the <code>/app</code> directory inside the container.</li> <li>This will load the environment variables from the <code>.env</code> file.</li> <li>This will expose the port <code>8000</code> of the container to the host machine's port <code>8000</code>.</li> <li>This will make sure that the <code>db</code> service is started before the <code>web</code> service.</li> <li>This <code>command</code> will wait for the <code>db</code> service to be ready before starting the Django server.</li> <li>The <code>db</code> service will use the <code>postgres:13.10-alpine</code> image.</li> <li>The <code>POSTGRES_PASSWORD</code> environment variable will set the Database password to <code>postgres</code>.</li> <li>The <code>volumes</code> will mount the <code>postgres_data</code> volume to the <code>/var/lib/postgresql/data/</code> directory inside the container. This will ensure that the database data is persisted between container restarts.</li> <li>This will check if the database is ready to accept connections.</li> <li>This will create a volume called <code>postgres_data</code> that will be used to persist the database data.</li> </ol> <p>We also need to create a <code>.env</code> file at the root of the project (<code>try-dj-pgbouncer/</code>) that will contain the environment variables for the <code>docker-compose</code> configuration.</p> <pre><code>touch .env\n</code></pre> <p>Add the following content to the <code>.env</code> file:</p> <pre><code>DATABASE_URL=postgres://postgres:postgres@db:5432/postgres\n</code></pre> How to get <code>DATABASE_URL</code> ? <p>The format of the <code>DATABASE_URL</code> is as follows:</p> <p><code>DATABASE_URL=&lt;ENGINE&gt;://&lt;USER&gt;:&lt;PASSWORD&gt;@&lt;HOST&gt;:&lt;PORT&gt;/&lt;NAME&gt;</code></p> <p>Where:</p> <ul> <li><code>ENGINE</code>  : The database engine. For PostgreSQL, it is <code>postgres</code>.</li> <li><code>USER</code>    : The database user.</li> <li><code>PASSWORD</code>: Password for the database user.</li> <li><code>HOST</code>    : The database host. As we are using docker-compose, we can use the service name (e.g: <code>db</code>) as the host.</li> <li><code>PORT</code>    : The port on which the database is accepting connections. For PostgreSQL, it is <code>5432</code>.</li> <li><code>NAME</code>    : Name of the database.</li> </ul>","tags":["python","django","postgresql","docker","pgbouncer","tutorial"]},{"location":"posts/django-postgresql-database-connection-pooling-with-pgbouncer/#configure-django-settings-to-use-postgresql","title":"Configure Django Settings to use PostgreSQL","text":"<p>We need to configure the Django settings to use PostgreSQL as the database engine. We will use the <code>dj-database-url</code> package to configure the database using a <code>DATABASE_URL</code> we defined in the <code>.env</code> file.</p> <p>Add the following content to the <code>try_dj_pgbouncer/settings.py</code> file:</p> try_dj_pgbouncer/settings.py<pre><code># ...\nimport dj_database_url  # (1)!\n# ...\nDATABASES = {\n'default': dj_database_url.config()  # (2)!\n}\n</code></pre> <ol> <li>This will import the <code>dj_database_url</code> package.</li> <li>Here we are using the <code>dj_database_url.config()</code> function to configure the <code>deafult</code> <code>DATABASES</code> setting for Django.    This function will read the <code>DATABASE_URL</code> environment variable and configure the <code>DATABASES</code> setting accordingly.</li> </ol> <p>This will configure the <code>DATABASES</code> setting to use PostgreSQL as the database engine.</p>","tags":["python","django","postgresql","docker","pgbouncer","tutorial"]},{"location":"posts/django-postgresql-database-connection-pooling-with-pgbouncer/#add-django-model-and-view","title":"Add Django Model and View","text":"<p>We need to add Django models and views to test the database connection pooling.</p> <p>First, we need to update <code>core/models.py</code> file to add the <code>Post</code> model:</p> core/models.py<pre><code>from django.db import models\nclass Post(models.Model):\ntitle = models.CharField(max_length=255)\ncontent = models.TextField()\n</code></pre> <p>Next, we need to update <code>core/admin.py</code> file to register the <code>Post</code> model:</p> core/admin.py<pre><code>from django.contrib import admin\nfrom .models import Post\nadmin.site.register(Post)\n</code></pre> <p>Then, we need to update <code>core/views.py</code> file to add the <code>PostistView</code> view:</p> core/views.py<pre><code>from django.views.generic import ListView\nfrom .models import Post\nclass PostistView(ListView):\nmodel = Post\ntemplate_name = 'core/post_list.html'\n</code></pre> <p>Now, we need to create <code>core/urls.py</code> file to add the <code>PostistView</code> view:</p> <pre><code>touch core/urls.py\n</code></pre> <p>Add the following content to the <code>core/urls.py</code> file:</p> core/urls.py<pre><code>from django.urls import path\nfrom .views import PostistView\nurlpatterns = [\npath('', PostistView.as_view(), name='post_list'),\n]\n</code></pre> <p>We also need to update <code>try_dj_pgbouncer/urls.py</code> file to include the <code>core.urls</code>:</p> try_dj_pgbouncer/urls.py<pre><code>from django.contrib import admin\nfrom django.urls import path, include  # (1)!\nurlpatterns = [\npath('admin/', admin.site.urls),\npath('', include('core.urls')),  # (2)!\n]\n</code></pre> <ol> <li>This will import the <code>include</code> function from the <code>django.urls</code> module.</li> <li>This will include the <code>core.urls</code> module.</li> </ol> <p>Finally, we need to create a template file <code>core/templates/core/post_list.html</code> to render the list of posts:</p> <pre><code>mkdir -p core/templates/core/ &amp;&amp; touch core/templates/core/post_list.html\n</code></pre> <p>Add the following content to the <code>core/templates/core/post_list.html</code> file:</p> core/templates/core/post_list.html<pre><code>&lt;!DOCTYPE html&gt;\n&lt;html lang=\"en\"&gt;\n&lt;meta charset=\"UTF-8\"&gt;\n&lt;meta name=\"viewport\" content=\"width=device-width,initial-scale=1\"&gt;\n&lt;title&gt;Post List&lt;/title&gt;\n&lt;body&gt;\n        {% block content %}\n            &lt;h1&gt;Post List&lt;/h1&gt;\n&lt;ul&gt;\n                {% for post in object_list %}\n                    &lt;li&gt;{{ post.title }}&lt;/li&gt;\n                {% endfor %}\n            &lt;/ul&gt;\n        {% endblock %}\n    &lt;/body&gt;\n&lt;/html&gt;\n</code></pre> <p>Now, we can run Django migrations to create the <code>Post</code> table in the database:</p> <pre><code>docker-compose run --rm web python manage.py makemigrations  # (1)!\ndocker-compose run --rm web python manage.py migrate  # (2)!\n</code></pre> <ol> <li>This will create the migration files for the <code>Post</code> model.</li> <li>This will run the migrations to create the <code>Post</code> table in the database.</li> </ol> <p>We also create an admin user to access the Django admin.</p> <pre><code>docker-compose run --rm web python manage.py createsuperuser </code></pre> <p>Now, we can run the Django development server.</p> <pre><code>docker-compose up --build\n</code></pre> <p>The Django development server will be available at: http://localhost:8000/</p> <p>We can also visit Django Admin at http://localhost:8000/admin/ and login with the admin user we created. Then we can create some posts from the Django admin.</p> <p>After creating some posts, we can visit the post list page at http://localhost:8000/ and see the list of posts.</p> <p>Note</p> <p>Here we are using PostgreSQL as the database engine for Django. In the next section, we will see how to use PgBouncer to provide database connection pooling for Django applications.</p> <p>Final Project Structure Should Look Like This:</p> <pre><code>try-dj-pgbouncer\n   \u251c\u2500\u2500 core\n   \u2502   \u251c\u2500\u2500 admin.py\n   \u2502   \u251c\u2500\u2500 apps.py\n   \u2502   \u251c\u2500\u2500 __init__.py\n   \u2502   \u251c\u2500\u2500 migrations\n   \u2502   \u2502   \u251c\u2500\u2500 0001_initial.py\n   \u2502   \u2502   \u2514\u2500\u2500 __init__.py\n   \u2502   \u251c\u2500\u2500 models.py\n   \u2502   \u251c\u2500\u2500 templates\n   \u2502   \u2502   \u2514\u2500\u2500 core\n   \u2502   \u2502       \u2514\u2500\u2500 post_list.html\n   \u2502   \u251c\u2500\u2500 tests.py\n   \u2502   \u251c\u2500\u2500 urls.py\n   \u2502   \u2514\u2500\u2500 views.py\n   \u251c\u2500\u2500 docker-compose.yaml\n   \u251c\u2500\u2500 Dockerfile\n   \u251c\u2500\u2500 manage.py\n   \u251c\u2500\u2500 requirements.txt\n   \u2514\u2500\u2500 try_dj_pgbouncer\n       \u251c\u2500\u2500 asgi.py\n       \u251c\u2500\u2500 __init__.py\n       \u251c\u2500\u2500 settings.py\n       \u251c\u2500\u2500 urls.py\n       \u2514\u2500\u2500 wsgi.py\n</code></pre>","tags":["python","django","postgresql","docker","pgbouncer","tutorial"]},{"location":"posts/django-postgresql-database-connection-pooling-with-pgbouncer/#add-and-configure-pgbouncer","title":"Add and Configure PgBouncer","text":"<p>We need to add PgBouncer service to our <code>docker-compose.yaml</code> file to provide database connection pooling for Django applications.</p> <p>Add the following content to the <code>docker-compose.yaml</code> file:</p> docker-compose.yaml<pre><code>version: '3.9'\nservices:\nweb:\nbuild:\ncontext: . volumes:\n- .:/app\nenv_file:\n- ./.env\nports:\n- 8000:8000\ndepends_on:\n- db\n- pgbouncer\ncommand: &gt;\nbash -c \"while !&lt;/dev/tcp/db/5432; do sleep 1; done;\npython manage.py runserver 0.0.0.0:8000\"\ndb:\nimage: postgres:13.10-alpine\nenvironment:\n- POSTGRES_PASSWORD=postgres\nvolumes:\n- postgres_data:/var/lib/postgresql/data/\nhealthcheck:\ntest: [\"CMD-SHELL\", \"pg_isready -U postgres\"]\ninterval: 10s\ntimeout: 5s\nretries: 5\npgbouncer:  # (1)!\nimage: edoburu/pgbouncer:1.18.0  # (2)!\nenv_file:\n- ./.env  # (3)!\nenvironment:\nDATABASE_URL: \"${POSTGRES_DATABASE_URL}\"  # (4)!\ndepends_on:\n- db  # (5)!\nvolumes:\npostgres_data:\n</code></pre> <ol> <li>This will add a new service named <code>pgbouncer</code>.</li> <li>We will use the <code>edoburu/pgbouncer:1.18.0</code> Docker image.</li> <li>This will load the environment variables from the <code>.env</code> file.</li> <li>This will set the <code>DATABASE_URL</code> environment variable to the <code>POSTGRES_DATABASE_URL</code> environment variable which will be set in the <code>.env</code> file.</li> <li>This will add a dependency on the <code>db</code> service. This will ensure that the <code>db</code> service will be started before the <code>pgbouncer</code> service.</li> </ol> <p>Why Use <code>edoburu/pgbouncer</code> Docker Image ?</p> <p>The official <code>pgbouncer/pgbouncer</code> Docker image was last updated 2 years ago (November 2020). But <code>edoburu/pgbouncer</code> is updated regularly and is the most popular (over 10+ Million downloads) PgBouncer Docker image on Docker Hub. You can also use <code>bitnami/pgbouncer</code> Docker image as an alternative which is also updated regularly. (Some of the configuration options are a bit different)</p> <p>Now, we need to update the <code>.env</code> file.</p> .env<pre><code>DATABASE_URL=postgres://postgres:postgres@pgbouncer:5432/postgres  # (1)!\nPOSTGRES_DATABASE_URL=postgres://postgres:postgres@db:5432/postgres  # (2)!\nPOOL_MODE=transaction  # (3)!\nMAX_DB_CONNECTIONS=100  # (4)!\nDEFAULT_POOL_SIZE=40  # (5)!\n</code></pre> <ol> <li>This will set the <code>DATABASE_URL</code> environment variable to use the <code>pgbouncer</code> service instead of the <code>db</code> service.</li> <li>This will set the <code>POSTGRES_DATABASE_URL</code> environment variable to use the <code>db</code> service. <code>pgbouncer</code> service will use this environment variable to connect to the <code>db</code> service.</li> <li>This will set the <code>POOL_MODE</code> to <code>transaction</code>. You can also set this to <code>session</code> or <code>statement</code> pooling mode. You can find more information about the different pooling modes in the official PgBouncer documentation.</li> <li>Do not allow more than this many server connections per database (regardless of user). This considers the PgBouncer database that the client has connected to, not the PostgreSQL database of the outgoing connection.</li> <li>How many server connections to allow per user/database pair.</li> </ol> <p>There are many other configuration options available in the official PgBouncer documentation. You can use environment variables to set these configuration options. The name of the environment variable should be the same as the name of the configuration option but capitalized. (e.g: <code>pool_mode</code> -&gt; <code>POOL_MODE</code>, <code>max_db_connections</code> -&gt; <code>MAX_DB_CONNECTIONS</code>)</p> <p>Note</p> <p>You can also use the <code>pgbouncer.ini</code> file to set the configuration options by attaching a volume (e.g: <code>pgbouncer.ini:/etc/pgbouncer/pgbouncer.ini:ro</code>). You can find more information about <code>pgbouncer.ini</code> in the official PgBouncer documentation.</p> <p>We also need to update Django settings file.</p> try_dj_pgbouncer/settings.py<pre><code># ...\nimport dj_database_url\n# ...\nDATABASES = {\n'default': dj_database_url.config()\n}\nDATABASES['default']['DISABLE_SERVER_SIDE_CURSORS'] = True\n</code></pre> Why are we setting <code>DISABLE_SERVER_SIDE_CURSORS</code> to <code>True</code> ? <p>Using a connection pooler in transaction pooling mode (e.g. PgBouncer) requires disabling server-side cursors for that connection. Server-side cursors are local to a connection and remain open at the end of a transaction when <code>AUTOCOMMIT</code> is <code>True</code>. A subsequent transaction may attempt to fetch more results from a server-side cursor. In transaction pooling mode, there\u2019s no guarantee that subsequent transactions will use the same connection. If a different connection is used, an error is raised when the transaction references the server-side cursor, because server-side cursors are only accessible in the connection in which they were created. One solution is to disable server-side cursors for a connection in <code>DATABASES</code> by setting <code>DISABLE_SERVER_SIDE_CURSORS</code> to True.</p> <p>Source: Django Transaction pooling and server-side cursors</p> <p>Now, we can run the development server again.</p> <pre><code>docker-compose down\ndocker-compose up --build\n</code></pre> <p>We can visit the post list page at http://localhost:8000/ and see the list of posts. Now Django server is using the <code>pgbouncer</code> service to connect to the <code>db</code> service.</p>","tags":["python","django","postgresql","docker","pgbouncer","tutorial"]},{"location":"posts/django-postgresql-database-connection-pooling-with-pgbouncer/#top-level-architecture-diagram","title":"Top Level Architecture Diagram","text":"<pre><code>flowchart LR\n\n    A[Browser] &lt;--&gt; B(Django)\n    B &lt;--&gt; C(PgBouncer)\n    C &lt;--&gt; id1[(PostgreSQL)]</code></pre>","tags":["python","django","postgresql","docker","pgbouncer","tutorial"]},{"location":"posts/django-postgresql-database-connection-pooling-with-pgbouncer/#references","title":"References","text":"<ul> <li>Django Transaction pooling and server-side cursors</li> <li>PgBouncer</li> <li>Edoburu PgBouncer Docker Hub</li> <li>Bitnami PgBouncer Docker Hub</li> <li>Official PgBouncer Docker Hub</li> </ul>","tags":["python","django","postgresql","docker","pgbouncer","tutorial"]},{"location":"posts/django-postgresql-database-connection-pooling-with-pgbouncer/#conclusion","title":"Conclusion","text":"<p>In this post, we learned how to use PostgreSQL database connection pooling with PgBouncer for Django applications. In production environments, PgBouncer can be really useful to reduce the number of connections to the database server and provide significant performance improvements. You can run PgBouncer as a separate service alongside you Django application and PostgreSQL database server. If your servers are hosted in AWS you can also check out  AWS RDS Proxy which is a managed service that provides connection pooling for RDS databases.</p>","tags":["python","django","postgresql","docker","pgbouncer","tutorial"]},{"location":"tags/","title":"Tags","text":"<p>Following is a list of relevant tags:</p>"},{"location":"tags/#cli","title":"cli","text":"<ul> <li>Build a Python CLI Tool with Rust</li> </ul>"},{"location":"tags/#django","title":"django","text":"<ul> <li>Django Database Connection Pooling with PgBouncer</li> </ul>"},{"location":"tags/#docker","title":"docker","text":"<ul> <li>Django Database Connection Pooling with PgBouncer</li> </ul>"},{"location":"tags/#pgbouncer","title":"pgbouncer","text":"<ul> <li>Django Database Connection Pooling with PgBouncer</li> </ul>"},{"location":"tags/#postgresql","title":"postgresql","text":"<ul> <li>Django Database Connection Pooling with PgBouncer</li> </ul>"},{"location":"tags/#python","title":"python","text":"<ul> <li>Build a Python CLI Tool with Rust</li> <li>Django Database Connection Pooling with PgBouncer</li> </ul>"},{"location":"tags/#rust","title":"rust","text":"<ul> <li>Build a Python CLI Tool with Rust</li> </ul>"},{"location":"tags/#tutorial","title":"tutorial","text":"<ul> <li>Build a Python CLI Tool with Rust</li> <li>Django Database Connection Pooling with PgBouncer</li> </ul>"}]}